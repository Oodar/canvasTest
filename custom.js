// Generated by CoffeeScript 1.3.1
(function() {
  var accum, addParticles, elapsedTime, overlay, particle, renderable, renderer, rgbaColor, update, vec2d, xPos, yPos,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  elapsedTime = 0;

  xPos = 0;

  yPos = 0;

  accum = 0;

  addParticles = true;

  overlay = false;

  renderer = (function() {

    renderer.name = 'renderer';

    function renderer(ctx, canvas, targetFrameRate) {
      this.ctx = ctx;
      this.canvas = canvas;
      this.targetFrameRate = targetFrameRate;
      this["do"] = __bind(this["do"], this);

      this.accum = 0;
    }

    renderer.prototype["do"] = function(objects, lastFrameTime) {
      var dT, obj, _i, _len;
      dT = (Date.now() / 1000) - lastFrameTime;
      this.accum += dT;
      this.frameTime = dT;
      if (this.accum > 1 / this.targetFrameRate) {
        this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (_i = 0, _len = objects.length; _i < _len; _i++) {
          obj = objects[_i];
          obj.render(this.ctx);
        }
        return this.accum = 0;
      }
    };

    renderer.prototype.frameRate = function() {
      return 1 / this.frameTime;
    };

    return renderer;

  })();

  renderable = (function() {

    renderable.name = 'renderable';

    function renderable(name) {
      this.name = name;
    }

    renderable.prototype.render = function(ctx) {
      return console.log("renderable::render()");
    };

    return renderable;

  })();

  vec2d = (function() {

    vec2d.name = 'vec2d';

    function vec2d(x, y) {
      this.x = x;
      this.y = y;
    }

    vec2d.prototype.add = function(x, y) {
      this.x += x;
      return this.y += y;
    };

    vec2d.prototype.mul = function(s) {
      this.x *= s;
      return this.y *= s;
    };

    return vec2d;

  })();

  rgbaColor = (function() {

    rgbaColor.name = 'rgbaColor';

    function rgbaColor(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

    rgbaColor.prototype.toString = function() {
      return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
    };

    return rgbaColor;

  })();

  particle = (function(_super) {

    __extends(particle, _super);

    particle.name = 'particle';

    function particle(pos, velocity, radius, color) {
      this.pos = pos;
      this.velocity = velocity;
      this.radius = radius;
      this.color = color;
      particle.__super__.constructor.call(this, this.name);
    }

    particle.prototype.update = function(dT) {
      this.pos.x += this.velocity.x * dT * 500;
      this.pos.y += this.velocity.y * dT * 500;
      return this.color.a -= 1 * dT;
    };

    particle.prototype.render = function(ctx) {
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, 15, 0, 2 * Math.PI, false);
      ctx.fillStyle = this.color.toString();
      return ctx.fill();
    };

    return particle;

  })(renderable);

  $(document).ready(function() {
    var canvas, ctx, i, now, objs, r, _i;
    canvas = $('#canvas')[0];
    if (canvas.getContext) {
      console.log('got 2d context');
      ctx = canvas.getContext('2d');
    } else {
      console.log('unable to get 2d context');
    }
    $('#off').click(function(e) {
      if (addParticles) {
        return addParticles = false;
      } else {
        return addParticles = true;
      }
    });
    $('#slide').click(function(e) {
      if (!overlay) {
        $('#overlayWrapper').animate({
          "left": "150"
        }, "slow");
        return overlay = true;
      } else {
        $('#overlayWrapper').animate({
          "left": "-200"
        }, "slow");
        return overlay = false;
      }
    });
    r = new renderer(ctx, canvas, 60);
    now = Date.now() / 1000;
    objs = [];
    for (i = _i = 1; _i <= 10; i = ++_i) {
      objs.push(new particle(new vec2d(canvas.width / 2, canvas.height / 2), new vec2d(Math.sin((Math.random() * 2) - 1), Math.sin((Math.random() * 2) - 1)), 10, new rgbaColor(parseInt(128 + (128 * Math.sin(Math.random()))), parseInt(128 + (128 * Math.cos(Math.random() * .5))), parseInt(128 + (128 * Math.sin(Math.random() * .25))), 1)));
    }
    return update(objs, r, now);
  });

  update = function(sceneObjects, sceneRenderer, lastFrameTime) {
    var dT, height, i, width, _i, _len;
    dT = Date.now() / 1000 - lastFrameTime;
    accum += lastFrameTime;
    if (addParticles) {
      sceneObjects.push(new particle(new vec2d(sceneRenderer.canvas.width / 2, sceneRenderer.canvas.height / 2), new vec2d(Math.sin((Math.random() * 2) - 1), Math.sin((Math.random() * 2) - 1)), 10, new rgbaColor(parseInt(128 + (128 * Math.sin(accum))), parseInt(128 + (128 * Math.cos(accum * .5))), parseInt(128 + (128 * Math.sin(accum * .25))), 1)));
    }
    for (_i = 0, _len = sceneObjects.length; _i < _len; _i++) {
      i = sceneObjects[_i];
      i.update(dT);
    }
    width = sceneRenderer.canvas.width;
    height = sceneRenderer.canvas.height;
    sceneObjects = (function() {
      var _j, _len1, _ref, _ref1, _results;
      _results = [];
      for (_j = 0, _len1 = sceneObjects.length; _j < _len1; _j++) {
        i = sceneObjects[_j];
        if ((0 < (_ref = i.pos.x) && _ref < width) && (0 < (_ref1 = i.pos.y) && _ref1 < height)) {
          _results.push(i);
        }
      }
      return _results;
    })();
    sceneRenderer["do"](sceneObjects, lastFrameTime);
    sceneRenderer.ctx.save();
    sceneRenderer.ctx.translate(10, 20);
    sceneRenderer.ctx.fillStyle = "#000";
    sceneRenderer.ctx.fillText("particles: " + sceneObjects.length, 0, 0);
    sceneRenderer.ctx.translate(0, 20);
    sceneRenderer.ctx.fillText("frame time: " + dT, 0, 0);
    sceneRenderer.ctx.restore();
    return setTimeout(update, 1000 / 120, sceneObjects, sceneRenderer, Date.now() / 1000);
  };

}).call(this);
